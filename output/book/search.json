[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bausteine Computergestützter Datenanalyse",
    "section": "",
    "text": "Methodenbaustein Datenfitting und Datenoptimierung\n\n\n\n\n\n\n\n\n\n\nBausteine Computergestützter Datenanalyse von Lukas Arnold, Simone Arnold, Florian Bagemihl, Matthias Baitsch, Marc Fehr, Franca Hollmann, Maik Poetzsch und Sebastian Seipel. Methodenbaustein Datenfitting und Datenoptimierung von Marc Fehr und Maik Poetzsch ist lizensiert unter CC BY 4.0. Das Werk ist abrufbar auf GitHub. Ausgenommen von der Lizenz sind alle Logos Dritter und anders gekennzeichneten Inhalte. 2025\n\n\n\nZitiervorschlag\nArnold, Lukas, Simone Arnold, Florian Bagemihl, Matthias Baitsch, Marc Fehr, Franca Hollmann, Maik Poetzsch, und Sebastian Seipel. 2025. “Bausteine Computergestützter Datenanalyse. Methodenbaustein Datenfitting und Datenoptimierung”. https://github.com/bausteine-der-datenanalyse/m-datenfitting-und-optimierunge.\nBibTeX-Vorlage\n@misc{BCD-m-datenfittung-und-optimierung-2025,\n title={Bausteine Computergestützter Datenanalyse. Methodenbaustein Datenfitting und Datenoptimierung.},\n author={Arnold, Lukas and Arnold, Simone and Bagemihl, Florian and Baitsch, Matthias and Fehr, Marc and Hollmann, Franca and Poetzsch, Maik and Seipel, Sebastian},\n year={2025},\n url={https://github.com/bausteine-der-datenanalyse/m-datenfitting-und-optimierung}} \n\n\n\nVoraussetzungen\nDie Bearbeitungszeit dieses Bausteins beträgt circa Platzhalter. Für die Bearbeitung dieses Bausteins werden folgende Bausteine vorausgesetzt:\n\nWerkzeugbaustein Python\nWerkzeugbaustein NumPy\n\nIn diesem Baustein werden die folgenden Module und Pakete verwendet:\n\nnumpy\n\nnumpy.polynomial\n\nmatplotlib.pyplot\n\nIm Baustein werden folgende Daten verwendet: Es werden keine von Dritten bezogene Daten verwendet.\n\n\nLernziele\nIn diesen Baustein lernen Sie …\n\nfehlende Daten in einem Datensatz mit Schätzwerten aufzufüllen.\nDaten mit einer Modellfunktion zu beschreiben.\nDaten mit mehreren Modellfunktionen zu beschreiben.\nverrauschte Daten zu glätten.",
    "crumbs": [
      "Methodenbaustein Datenfitting und Datenoptimierung"
    ]
  },
  {
    "objectID": "skript/einleitung.html",
    "href": "skript/einleitung.html",
    "title": "1  Einleitung",
    "section": "",
    "text": "Experiementell gewonnene Daten können stark verrauscht sein oder die Beziehung der Veriablen wird am besten durch einen nicht-linearen Zusammenhang beschrieben. Datenfitting ist der Prozess, ein Modell an einen Datensatz anzupassen, um die zugrundeliegende Beziehung zwischen den Variablen zu beschreiben, die Daten zu glätten oder Werte zwischen den vorhandenen Datenpunkten zu schätzen. Das Ziel dieses Prozesses ist es, eine Funktion zu finden, die den Datensatz so gut wie möglich beschreibt, indem die Abweichung zwischen dem Modell und den tatsächlichen Daten minimiert wird. Man nennt diesen Prozess auch Modellierung.\nIn diesem Baustein werden die folgenden Module verwendet:\n\nimport numpy as np\nimport numpy.polynomial.polynomial as poly\nimport matplotlib.pyplot as plt\n\nDie Modellierung von Daten kann auf folgendes Problem verallgemeinert werden:\n\nGegeben sind \\(n\\) Messpunktpaare \\((x_i, y_i)\\) mit \\(x_i, y_i \\in \\mathbb{R}\\).\nGesucht ist eine Modellfunktion \\(y(x)\\), welche die Messpunktpaare approximiert.\n\nEin möglicher Ansatz ist die Darstellung der Modellfunktion als Summe von \\(m\\) Basisfunktionen \\(\\phi_i(x)\\) mit den Koeffizienten \\(\\beta_i\\). \\[\ny(x) = \\sum_{i=1}^{m}\\beta_i \\cdot \\phi_i(x) = \\beta_1\\cdot \\phi_1(x) + \\cdots + \\beta_m\\cdot \\phi_m(x)\n\\]\nDie Koeffizienten \\(\\beta_i\\) müssen dabei so bestimmt werden, dass \\(y(x)\\) so gut wie möglich – oder gar exakt – die Messpunkte approximiert.\nAls Abstandmaß zwischen einer Modellfunktion und den Messpunkten kann die Methode der kleinsten Quadrate genutzt werden.\n\n\n\n\n\n\nBeispiel 1.2: Methode der kleinsten Quadrate\n\n\n\n\n\nMit der Methode der kleinsten Quadrate soll diejenige Gerade \\(\\hat{y} = \\beta_0 + \\beta_1 \\cdot x\\) gefunden werden, die die quadrierten Abstände der Vorhersagewerte \\(\\hat{y}\\) von den tatsächlich gemessenen Werten \\(y\\) minimiert. Die Werte \\(y_i - \\hat{y_i}\\) sind die Residuen \\(e_i\\). Es gilt also:\n\\[\n\\sum_{i=1}^{N}(y_i - \\hat{y_i})^2 = \\sum_{i=1}^{N} e_i = \\min\n\\]\nGrafisch kann man sich die Minimierung der quadrierten Abstände so vorstellen.\n\nGrafikCode\n\n\n\n\n\n\n\n\n\n\n\nRegressionskoeffizienten: [ 2.93333333 -0.73333333]\n\n\n\n\n\nx = np.arange(1, 11)\ny = - x.copy() + 4\ny[0] -= 2\ny[2] -= 2\ny[3] += 3\ny[-3] += 5\n\nlm = poly.polyfit(x, y, 1)\nvorhersagewerte = poly.polyval(x, lm)\n\nplt.scatter(x, vorhersagewerte, label = 'Vorhersagewerte', marker = \"^\", color = \"tab:blue\")\nplt.scatter(x, y, label = 'Messwerte', marker = 'o', color = \"tab:orange\")\nplt.axline(xy1 = (0, lm[0]), slope = lm[1], label = \"Regressionsgerade\", color = \"tab:blue\")\ndotted = plt.vlines(x, ymin = vorhersagewerte, ymax = y, alpha = 0.6, ls = 'dotted', label = 'Residuen')\n\nplt.legend()\nplt.show()\n\nprint(\"Regressionskoeffizienten:\", lm)\n\n\n\n\n \nDie eingezeichnete Gerade entspricht der linearen Funktion \\(\\hat{y} = \\beta_0 + \\beta_1 \\cdot x + e_i\\). Die Dreiecksmarker sind die Vorhersagewerte \\(\\hat{y_i}\\) des linearen Modells für die Werte \\(x_i = np.arange(1, 11)\\). Die tatsächlichen Messwerte \\(y\\) sind mit Kreismarkern markiert. Die Länge der gestrichelten Linien entspricht der Größe der Abweichung zwischen den Mess- und Vorhersagewerten \\(y_i - \\hat{y_i}\\), also den Residuen \\(e_i\\).\nGesucht wird diejenige Gerade, die die Summe der quadrierten Residuen minimiert. Die gesuchten Werte \\(\\beta_0\\) und \\(\\beta_1\\) sind die Kleinst-Quadrate-Schätzer.\n\\[\n\\beta_0 = \\bar{y} - \\beta_1 \\cdot \\bar{x}\n\\]\n\\[\n\\beta_1 = { \\sum_{i=1}^n (x_i- \\bar{x}) \\cdot (y_i - \\bar{y}) \\over \\sum_{i=1}^n (x_i - \\bar{x})^2 }\n\\]\nDer Vollständigkeit halber leiten wir die Kleinst-Quadrate-Schätzer her. Gesucht werden Werte für \\(\\beta_0\\) und \\(\\beta_1\\), damit die Summe der Residuenquadrate \\(\\sum_{i=1}^{n} e_i^2\\) möglichst klein wird. Die Residuenquadratsumme ist die Summe der quadrierten Differenzen aus beobachteten Werten \\(y_i\\) und der durch die lineare Funktion vorhergesagten Werte. \\[\n\\sum_{i=1}^{n} e_i^2 ~ = ~ \\sum_{i=1}^{n} (y_i - (\\beta_0 + \\beta_1 \\cdot x_i))^2\n\\]\nWir untersuchen also eine Funktion, die von zwei Variablen abhängig ist. \\[\nf(\\beta_0, \\beta_1) = \\sum_{i=1}^{n} (y_i - (\\beta_0 + \\beta_1 \\cdot x_i))^2\n\\]\nDas Summenzeichen ist die Kurzschreibweise für eine Summe. \\[\nf(\\beta_0, \\beta_1) = (y_1 - (\\beta_0 + \\beta_1 \\cdot x_1))^2 ~ + ~ (y_2 - (\\beta_0 + \\beta_1 \\cdot x_2))^2 ~ + ~ ... ~ (y_n - (\\beta_0 + \\beta_1 \\cdot x_n))^2\n\\]\nIm Minimum der Funktion müssen die beiden partiellen Ableitungen gleich Null sein (Warum das so ist, wird hier leicht verständlich erklärt.)\n\n\n\n\n\n\nBeispiel 1.1: Partielle Ableitung\n\n\n\n\n\nDie partielle Ableitung ist die Ableitung einer Funktion mit mehreren Variablen nach einer Variablen, wobei die übrigen Variablen als Konstanten behandelt werden.\nFür eine Funktion \\(f(x, y) = 2x + y^2\\) wird die partielle Ableitung nach x so ausgedrückt:\n\\(\\frac{\\partial f(x, y)}{\\partial x}\\)\n\nDas Symbol ∂ ist die kursive Darstellung des kyrillischen Kleinbuchstaben д (d) und wird als “del” gelesen. Es zeigt an, das eine partielle Ableitung durchgeführt wird.\nIm Zähler steht die Funktion, die abgeleitet werden soll. Im Nenner steht die Variable nach der abgeleitet wird. Der Term wird gelesen als “del f von x und y nach del x”.\n\nDie partielle Ableitung \\(\\frac{\\partial f(x, y)}{\\partial x} = 2\\). \\(y^2\\) wird als Konstante behandelt (z. B. \\(5^2\\) ) und ist abgeleitet Null.\nDie partielle Ableitung \\(\\frac{\\partial f(x, y)}{\\partial y} = 2y\\). \\(2x\\) wird als Konstante behandelt (z. B. \\(2 \\cdot 3\\) ) und ist abgeleitet Null.\n\n\n\nIn beiden partiellen Ableitungen sind \\(x_i\\) und \\(y_i\\) konstant. In der partiellen Ableitung nach \\(\\beta_0\\) ist außerdem \\(\\beta_1\\) konstant, in der partiellen Ableitung nach \\(\\beta_1\\) ist entsprechend \\(\\beta_0\\) konstant.\n\npartielle Ableitung nach dem y-Achsenschnittpunktpartielle Ableitung nach dem Anstieg\n\n\nFür die partielle Ableitung nach \\(\\beta_0\\) gilt also nach der Kettenregel für die äußere Funktion (oben) und die innere Funktion (Mitte): \\[ \\begin{aligned}\n\\frac{\\partial f(\\beta_0, \\beta_1)}{\\partial \\beta_0} = 2 \\cdot (y_1 - (\\beta_0 + \\beta_1 \\cdot x_1)) ~ + ~ ... ~ (y_n - (\\beta_0 + \\beta_1 \\cdot x_n)) = 2 \\cdot \\sum_{i=1}^{n} (y_i - (\\beta_0 + \\beta_1 \\cdot x_i)) ~ \\cdot\n\\newline\n(0 - (1 + 0 \\cdot 0)) ~ + ~ ... ~ (0 - (1 + 0 \\cdot 0)) = \\sum_{i=1}^{n} (0 - (1 + 0 \\cdot 0)) =\n\\newline\n2 \\cdot \\sum_{i=1}^{n} (y_i - (\\beta_0 + \\beta_1 \\cdot x_i)) ~ \\cdot (-1)\n\\end{aligned}\n\\]\nFür die partielle Ableitung nach \\(\\beta_0\\) gilt also: \\[\n\\frac{\\partial f(\\beta_0, \\beta_1)}{\\partial \\beta_0} = -2 \\cdot \\sum_{i=1}^{n} (y_i - (\\beta_0 + \\beta_1 \\cdot x_i)) = 0\n\\]\nDiese kann vereinfacht werden, indem der Vorfaktor \\(-2\\) entfällt (weil \\(-2 \\cdot 0 = 0\\) gelten muss) und die Vorzeichen aufgelöst werden. Sodass: \\[\n\\sum_{i=1}^{n} (y_i - \\beta_0 - \\beta_1 \\cdot x_i) = 0\n\\]\nMan kann auch schreiben: \\[\n\\sum_{i=1}^{n} y_i - \\sum_{i=1}^{n} \\beta_0 - \\sum_{i=1}^{n} \\beta_1 \\cdot x_i = 0\n\\]\n\\(\\beta_0\\) und \\(\\beta_1\\) sind Konstanten, sodass gilt \\(\\sum_{i=1}^{n} \\beta_0  = \\beta_0 \\cdot \\sum_{i=1}^{n} 1 = \\beta_0 \\cdot n\\) und \\(\\sum_{i=1}^{n} \\beta_1 \\cdot x_i = \\beta_1 \\cdot \\sum_{i=1}^{n} 1 \\cdot x_i\\). So gilt: \\[\n\\sum_{i=1}^{n} y_i - n \\cdot \\beta_0 - \\beta_1 \\cdot \\sum_{i=1}^{n} x_i = 0\n\\]\nJetzt kann man durch \\(n\\) teilen. Dabei entspricht \\(\\frac{\\sum_{i=1}^{n}y_i}{n}\\) dem arithmetischen Mittelwert von \\(y\\) und \\(\\frac{\\sum_{i=1}^{n}x_i}{n}\\) dem arithmetischen Mittelwert von \\(x\\). Somit steht: \\[\n\\bar{y} - \\beta_0 - \\beta_1 \\cdot \\bar{x}= 0\n\\]\nUmgestellt: \\[\n\\beta_0 = \\bar{y} - \\beta_1 \\cdot \\bar{x}\n\\]\n\n\nFür die partielle Ableitung nach \\(\\beta_1\\) ist ebenfalls die Kettenregel anzuwenden, sodass die äußere Funktion (oben) identisch abgeleitet wird: \\[ \\begin{aligned}\n\\frac{\\partial f(\\beta_0, \\beta_1)}{\\partial \\beta_1} = 2 \\cdot (y_1 - (\\beta_0 + \\beta_1 \\cdot x_1)) ~ + ~ ... ~ (y_n - (\\beta_0 + \\beta_1 \\cdot x_n)) = 2 \\cdot \\sum_{i=1}^{n} (y_i - (\\beta_0 + \\beta_1 \\cdot x_i)) ~ \\cdot\n\\newline\n(0 - (0 + 1 \\cdot x_1)) ~ + ~ ... ~ (0 - (0 + 1 \\cdot x_n)) ~ = ~ \\sum_{i=1}^{n} -x_i =\n\\newline\n2 \\cdot \\sum_{i=1}^{n} (y_i - (\\beta_0 + \\beta_1 \\cdot x_i)) ~ \\cdot -x_i\n\\end{aligned}\n\\]\nFür die partielle Ableitung nach \\(\\beta_1\\) gilt also: \\[\n\\frac{\\partial f(\\beta_0, \\beta_1)}{\\partial \\beta_1} = -2 \\sum_{i=1}^{n} x_i \\cdot (y_i - (\\beta_0 + \\beta_1 \\cdot x_i)) = 0\n\\]\nAuch diese kann vereinfacht werden, indem der Vorfaktor \\(-2\\) entfällt (weil \\(-2 \\cdot 0 = 0\\) gelten muss) und die Vorzeichen aufgelöst werden. Außerdem kann ausmultipliziert werden: \\[\n\\sum_{i=1}^{n} x_iy_i - \\sum_{i=1}^{n}  \\beta_0 \\cdot x_i - \\sum_{i=1}^{n}  \\beta_1 \\cdot x_ix_i = 0\n\\]\nWieder können die Konstanten herausgezogen werden: \\[\n\\sum_{i=1}^{n} x_iy_i - \\beta_0 \\cdot \\sum_{i=1}^{n} x_i - \\beta_1 \\cdot \\sum_{i=1}^{n} x_ix_i = 0\n\\]\nJetzt kann man \\(\\beta_0 = \\bar{y} - \\beta_1 \\cdot \\bar{x}\\) und \\(\\sum_{i=1}^{n} x_i = n \\cdot \\bar{x}\\) einsetzen: \\[\n\\sum_{i=1}^{n} x_iy_i - (\\bar{y} - \\beta_1 \\cdot \\bar{x}) \\cdot  n \\cdot \\bar{x} - \\beta_1 \\cdot \\sum_{i=1}^{n} x_ix_i = 0\n\\]\nDer mittlere Term wird ausmultipliziert und \\(x_ix_i\\) im letzten Term als \\(x_i^2\\) geschrieben: \\[\n\\sum_{i=1}^{n} x_iy_i - n\\bar{x}\\bar{y} - \\beta_1 \\cdot n\\bar{x}\\bar{x} - \\beta_1 \\cdot \\sum_{i=1}^{n} x_i^2 = 0\n\\]\nDie letzten beiden Terme werden unter Anwendung des Distributivgesetzes \\(a−b = − (b−a)\\) zusammengefasst. \\[\n\\sum_{i=1}^{n} x_iy_i - n\\bar{x}\\bar{y} - \\beta_1 \\cdot ( \\sum_{i=1}^{n} x_i^2 - n \\bar{x}^2) = 0\n\\]\nJetzt kann nach \\(\\beta_1\\) umgestellt werden. Erst: \\[\n\\beta_1 \\cdot ( \\sum_{i=1}^{n} x_i^2 - n \\bar{x}^2) = \\sum_{i=1}^{n} x_iy_i - n\\bar{x}\\bar{y}\n\\]\nDann: \\[\n\\beta_1 = \\frac{\\sum_{i=1}^{n} x_iy_i - n\\bar{x}\\bar{y}}{\\sum_{i=1}^{n} x_i^2 - n \\bar{x}^2}\n\\]\nNun kann zuerst mit \\(\\sum_{i=1}^{n} x_i^2 - n \\bar{x}^2 = \\sum_{i=1}^{n} (x_i - \\bar{x})^2\\) umgeformt werden. \\[\n\\beta_1 = \\frac{\\sum_{i=1}^{n} x_iy_i - n\\bar{x}\\bar{y}}{\\sum_{i=1}^{n}  (x_i - \\bar{x})^2}\n\\]\nDann - und das wird gleich gezeigt - mit \\(\\sum_{i=1}^{n} x_iy_i - n\\bar{x}\\bar{y} = \\sum_{i=1}^{n} (x_i - \\bar{x}) (y_i - \\bar{y})\\). Sodass steht: \\[\n\\beta_1 = \\frac{\\sum_{i=1}^{n} (x_i - \\bar{x}) (y_i - \\bar{y})}{\\sum_{i=1}^{n}  (x_i - \\bar{x})^2}\n\\]\nDer letzte Schritt wird ausgehend vom Ergebnis gezeigt und beginnt mit dem Ausmultiplizieren: \\[\n\\sum_{i=1}^{n} (x_i - \\bar{x}) (y_i - \\bar{y}) = \\sum_{i=1}^{n} (x_iy_i - x_i\\bar{y} - \\bar{x}y_i + \\bar{x}\\bar{y})\n\\]\nMan kann auch schreiben: \\[\n\\sum_{i=1}^{n} x_iy_i - \\sum_{i=1}^{n} x_i\\bar{y} - \\sum_{i=1}^{n} \\bar{x}y_i + \\sum_{i=1}^{n} \\bar{x}\\bar{y}\n\\]\n\\(\\bar{x}\\) und \\(\\bar{y}\\) sind Konstanten, sodass \\(\\bar{x} \\cdot \\sum_{i=1}^{n} y_i\\) und \\(\\bar{y} \\cdot \\sum_{i=1}^{n} x_i\\) geschrieben werden kann. \\(\\sum_{i=1}^{n} x_i\\) ist gleich \\(n \\cdot \\bar{x}\\) (analog für \\(y\\)). So ergibt sich:\n\\[\n\\sum_{i=1}^{n} x_iy_i - \\bar{y} \\cdot n \\cdot \\bar{x} - \\bar{x} \\cdot n \\cdot \\bar{y} + \\sum_{i=1}^{n} \\bar{x}\\bar{y}\n\\]\nSortieren: \\[\n\\sum_{i=1}^{n} x_iy_i - n\\bar{x}\\bar{y}  -  n\\bar{x}\\bar{y} + \\sum_{i=1}^{n} \\bar{x}\\bar{y}\n\\]\nDer letzte Term \\(\\sum_{i=1}^{n} \\bar{x}\\bar{y}\\) kann auch \\(n \\cdot \\bar{x}\\bar{y}\\) geschrieben werden, sodass sich ergibt: \\[\n\\sum_{i=1}^{n} x_iy_i - n\\bar{x}\\bar{y} - n\\bar{x}\\bar{y} + n\\bar{x}\\bar{y}\n\\]\nDie letzten beiden Terme entfallen somit und es bleibt: \\[\n\\sum_{i=1}^{n} x_iy_i - n\\bar{x}\\bar{y}\n\\]\n(Baitsch, Matthias 2019, 73–74)\n\n\n\n\n\n\nIn diesem Kapitel werden folgende Verfahren für die Modellierung von Daten vorgestellt:\n\ndie Polynominterpolation,\nDatenfitting durch Polynome und\nDatenfitting durch Splines.\n\n\n\n\n\nBaitsch, Matthias. 2019. „Vorlesungsskript Mathematik B (Master) Stochastik“. Hochschule Bochum.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "skript/interpolation.html",
    "href": "skript/interpolation.html",
    "title": "2  Interpolation – Lücken schließen",
    "section": "",
    "text": "2.1 Übersicht\nWas tun, wenn Werte fehlen? In vielen Datensätzen gibt es Lücken – zum Beispiel, weil Messungen nur an bestimmten Punkten vorgenommen wurden. Interpolation ist eine Methode, mit der wir Zwischenwerte schätzen können, also Werte innerhalb eines bekannten Wertebereichs.\nIm Gegensatz dazu versucht Extrapolation, Werte außerhalb des bekannten Bereichs vorherzusagen – was in der Regel mit größerer Unsicherheit verbunden ist.\nBei der Interpolation wird eine Modellfunktion gesucht, welche die Messdaten exakt abbildet.\nIn vielen praktischen Anwendungen werden Polynome als Basisfunktionen der Modellfunktion angenommen. Vorteile von Polynomen:\nEin Beispiel für eine Basis aus Polynomen:\n\\[ \\phi_1(x)=1,\\quad \\phi_2(x)=x,\\quad \\phi_3(x)=x^2,\\quad \\cdots,\\quad \\phi_m =x^{m-1} \\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Interpolation – Lücken schließen</span>"
    ]
  },
  {
    "objectID": "skript/interpolation.html#übersicht",
    "href": "skript/interpolation.html#übersicht",
    "title": "2  Interpolation – Lücken schließen",
    "section": "",
    "text": "Polynome sind leicht zu differenzieren und integrieren.\nMit Polynomen können beliebige Funktionen angenommen werden, siehe Taylor-Entwicklung.\nDie Auswertung benötigt nur wenige arithmetische Operationen (Addition und Multiplikation) und ist dadurch einfach und schnell anzuwenden.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Interpolation – Lücken schließen</span>"
    ]
  },
  {
    "objectID": "skript/interpolation.html#polynome",
    "href": "skript/interpolation.html#polynome",
    "title": "2  Interpolation – Lücken schließen",
    "section": "2.2 Polynome",
    "text": "2.2 Polynome\nPolynome \\(P(x)\\) sind Funktionen in Form einer Summe von Potenzfunktionen mit natürlichzahligen Exponenten \\(( x^i, i \\in \\mathbb{N})\\) mit den entsprechenden Koeffzienten \\(a_i\\):\n\\[\nP(x) = \\sum_{i=0}^n a_i x^i = a_n x^n + a_{n-1} x^{n-1} + \\cdots + a_2 x^2 + a_1 x + a_0, \\quad i, n \\in \\mathbb{N}, a_i \\in \\mathbb{R}\n\\]\n\nAls Grad eines Polynoms wird der Term mit dem höchsten Exponenten und nichtverschwindenden Koeffizienten (der sogenannte Leitkoeffizient) bezeichnet.\nEin Polynom mit Grad \\(n\\) hat \\(n\\), teilweise komplexe, Nullstellen.\n\nIm NumPy-Modul werden Polynome durch ihre Koeffizienten repräsentiert. Im Allgemeinen wird ein Polynom mit dem Grad \\(n\\) durch folgendes Array dargestellt\n[a0, a1, a2, ..., an]\nBeispielsweise für \\(P(x) = 3 -2x + 5x^2 + x^3\\):\n\nP = np.array([3, -2, 5, 1])\nprint(P)\n\n[ 3 -2  5  1]\n\n\nFunktionen für die Auswertung von Polynomfunktionen stellt das Paket numpy.polynomial bzw. dessen Modul numpy.polynomial.polynomial bereit.\n\nimport numpy.polynomial.polynomial as poly\n\nDie Auswertung des Polynoms an einem Punkt oder einem Array erfolgt mit der poly.polyval(x, c)-Funktion. Diese berechnet die Funktionswerte für in x übergebene Werte mit den Funktionsparametern c.\n\nx = 1\ny = poly.polyval(x, P)\nprint(f\"P(x={x}) = {y}\")\n\nP(x=1) = 7.0\n\n\n\nx = np.array([-1, 0, 1])\ny = poly.polyval(x, P)\nprint(f\"P(x={x}) = {y}\")\n\nP(x=[-1  0  1]) = [9. 3. 7.]\n\n\nFür die graphische Darstellung im Bereich \\(x \\in [-6, 2]\\) kann das Paket Matplotlib verwendet werden.\n\nx = np.linspace(-6, 2, 50)\ny = poly.polyval(x, P)\n\nplt.plot(x, y)\nplt.xlabel('x')\nplt.ylabel('y(x)')\nplt.grid()\n\nplt.show()\n\n\n\n\n\n\n\n\n \nUm die Nullstellen eines Polynoms zu finden, kann die Funktion poly.polyroots() genutzt werden. Für das obige Polynom können folgende Nullstellen bestimmt werden.\n\nnullstellen = poly.polyroots(P)\n\n# direkte Ausgabe des Arrays\nprint(\"Nullstellen: \")\nprint(nullstellen)\n\nNullstellen: \n[-5.46628038+0.j        0.23314019-0.703182j  0.23314019+0.703182j]\n\n\n\nprint(\"Nullstellen: \")\n# schönere Ausgabe des Arrays\nfor i, z in enumerate(nullstellen):\n    if z.imag == 0:\n        print(f\"  x_{i+1} = {z.real:.2}\")\n    else:\n        print(f\"  x_{i+1} = {z.real:.2} {z.imag:+.2}i\")\n\nNullstellen: \n  x_1 = -5.5\n  x_2 = 0.23 -0.7i\n  x_3 = 0.23 +0.7i\n\n\nIn diesem Beispiel sind zwei der Nullstellen komplex. Eine komplexe Zahl \\(z\\) wird in Python als Summe des Realteils (\\(Re\\)) und Imaginärteils (\\(Im\\)) dargestellt. Letzterer wird durch ein nachfolgendes j, die imaginäre Einheit, gekennzeichnet.\n\\[\nz = Re(z) + Im(z)j\n\\]\nDie Nullstellen können auch zur alternativen Darstellung des Polynoms verwendet werden. Sind \\(x_i\\) die \\(n\\) Nullstellen, so ist das Polynom \\(n\\)-ten Grades durch folgendes Produkt beschrieben:\n\\[\nP(x) = \\prod_{i=1}^n \\left(x - x_i\\right) = (x - x_1)\\cdot (x - x_2) \\cdot \\cdots \\cdot (x - x_n)\n\\]\nSeien beispielsweise 1 und 2 die Nullstellen eines Polynoms, so lautet dieses:\n\\[\nP(x) = (x - 1)(x - 2) = 2 - 3x + x^2\n\\]\nDie Funktion poly.polyfromroots(nullstellen) kann aus den Nullstellen die Polynomkoeffizienten bestimmen. Anhand des obigen Beispiels lautet der Funktionsaufruf:\n\nnullstellen = [1, 2]\nkoeffizienten = poly.polyfromroots(nullstellen)\n\nprint(\"Nullstellen:\", nullstellen)\nprint(\"Koeffizienten:\", koeffizienten)\n\nNullstellen: [1, 2]\nKoeffizienten: [ 2. -3.  1.]\n\n\nDas Modul numpy.polynomial.polynomial stellt viele praktische Funktionen zum Umgang mit Polynomen zur Verfügung. So existieren weitere Funktionen, um Polynome zu addieren, zu multiplizieren, abzuleiten oder zu integrieren. Eine Übersicht findet sich in der numpy-Dokumentation.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Interpolation – Lücken schließen</span>"
    ]
  },
  {
    "objectID": "skript/interpolation.html#polynominterpolation",
    "href": "skript/interpolation.html#polynominterpolation",
    "title": "2  Interpolation – Lücken schließen",
    "section": "2.3 Polynominterpolation",
    "text": "2.3 Polynominterpolation\nInterpolation ist eine Methode, um Datenpunkte zwischen gegebenen Messpunkten zu konstruieren. Dazu wird eine Funktion gesucht, die alle Messpunkte exakt abbildet, was gleichbedeutend damit ist, dass die L2-Norm zwischen Funktion und Punkten Null ist.\nZwei Punkte können z. B. mit einer Geraden interpoliert werden. Das heißt, für zwei Messpunktpaare \\((x_1, y_1)\\) und \\((x_2, y_2)\\) mit \\(x_1\\neq x_2\\) existiert ein Koeffizientensatz, sodass die L2-Norm zwischen den Messpunkten und der Modellfunktion\n\\[\ny(x) = \\beta_0 + \\beta_1 x\n\\]\nverschwindet.\n\n# Beispieldaten aus y(x) = 2 - x\n\nN = 50\ndx = 0.25\n\ndef fnk(x):\n    return 2 - x\n\nx = np.array([1, 2])\ny = fnk(x)\n\nplt.scatter(x, y, color='C1', label=\"Messpunkte\", zorder=3)\n\nx_modell = np.linspace(np.min(x), np.max(x), N)\nplt.plot(x_modell, fnk(x_modell), color='C0', label=\"Modellfunktion\")\n\nx_linie = np.linspace(np.min(x)-dx, np.max(x)+dx, N)\nplt.plot(x_linie, fnk(x_linie), '--', alpha=0.3, color='C0')\n\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.legend()\nplt.grid()\n\nplt.show()\n\n\n\n\n\n\n\n\n \nFür drei Messpunkte muss ein Polynom zweiten Grades verwendet werden, um die Punkte exakt zu erfassen.\n\\[\ny(x) = \\beta_0 + \\beta_1 x + \\beta_2 x^2\n\\]\n\n# Beispieldaten aus y(x) = -1 - 4x + 3x^2\n\nN = 50\ndx = 0.25\n\ndef fnk(x):\n    return -1 - 4*x + 3*x**2\n\nx = np.array([-1, 2, 3])\ny = fnk(x)\n\nplt.scatter(x, y, color='C1', label=\"Messpunkte\", zorder=3)\n\nx_modell = np.linspace(np.min(x), np.max(x), N)\nplt.plot(x_modell, fnk(x_modell), color='C0', label=\"Modellfunktion\")\n\nx_linie = np.linspace(np.min(x)-dx, np.max(x)+dx, N)\nplt.plot(x_linie, fnk(x_linie), '--', alpha=0.3, color='C0')\n\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.legend()\nplt.grid()\n\nplt.show()\n\n\n\n\n\n\n\n\nDies kann verallgemeinert werden: \\(n\\) Messpunkte können exakt mit einem Polynom (\\(n-1\\))-ten Grades abgebildet werden. Die Suche nach den passenden Koeffizienten ist das Lagrangesche Interpolationsproblem. Für das gesuchte Polynom \\(P(x)\\) gilt:\n\\[\nP(x_i) = y_i \\quad i \\in 1, \\dots, n\n\\]\nDie Existenz und Eindeutigkeit eines solchen Polynoms kann gezeigt werden. Das gesuchte Polynom lautet:\n\\[  P(x) = \\sum_{i=1}^n y_i I_i(x) \\] \\[  \\text{mit}\\quad I_i(x) = \\prod_{j=1, i\\neq j}^n \\frac{x-x_j}{x_i - x_j} \\]\nAlternativ kann auch ein Gleichungssystem, welches durch die Polynomialbasis \\(\\phi_i(x)\\) gegeben ist, gelöst werden. Für die \\(n\\) Punktepaare gilt jeweils:\n\\[  y(x_i) = \\sum_{i=1}^{m}\\beta_i \\cdot \\phi_i(x_i) = \\beta_1\\cdot \\phi_1(x_i) + \\cdots + \\beta_m\\cdot \\phi_m(x_i) = y_i \\]\nDas allgemeine Geleichungssystem lautet\n\\[\n\\left( \\begin{matrix} \\phi_1(x_1) & \\phi_2(x_1) & \\cdots & \\phi_m(x_1) \\\\\n             \\phi_1(x_2) & \\phi_2(x_2) & \\cdots & \\phi_m(x_2) \\\\\n             \\vdots &\\vdots & \\ddots & \\vdots \\\\\n             \\phi_1(x_n) & \\phi_2(x_n) & \\cdots & \\phi_m(x_n) \\\\\n             \\end{matrix}\\right).\n\\left(  \\begin{matrix} \\beta_1 \\\\  \n      \\beta_2 \\\\   \\vdots \\\\   \\beta_m \\\\\n      \\end{matrix} \\right)\n= \\left(  \\begin{matrix} y_1 \\\\  y_2 \\\\   \\vdots \\\\   y_n \\\\ \\end{matrix} \\right)\n\\]\nund mit der Polynomialbasis\n\\[\n\\underbrace{\\left( \\begin{matrix} 1 & x_1 & \\cdots & x_1^{n-1} \\\\ 1 & x_2 & \\cdots & x_2^{n-1} \\\\ \\vdots &\\vdots & \\ddots & \\vdots \\\\ 1 & x_n & \\cdots & x_n^{n-1} \\\\ \\end{matrix}\\right)}_{V}. \\left(  \\begin{matrix} \\beta_1 \\\\  \\beta_2 \\\\   \\vdots \\\\   \\beta_m \\\\ \\end{matrix} \\right) = \\left(  \\begin{matrix} y_1 \\\\  y_2 \\\\   \\vdots \\\\   y_n \\\\ \\end{matrix} \\right)\n\\]\nDie Matrix \\(V\\) heisst Vandermonde-Matrix und kann exakt gelöst werden, für \\(m=n\\) und wenn für alle \\(i, j; i\\neq j\\) gilt \\(x_i \\neq x_j\\).\nIn Python kann das Interpolationsproblem mit der Funktion numpy.polynomial.polynomial.polyfit() gelöst werden, das wir durch durch das Importieren des Moduls mit dem Schlüsselwort poly mit poly.polyfit() aufrufen können. Das folgende Beispiel demonstriert deren Anwendung.\nDie Messtellen folgen in dem Beispiel der Funktion \\(f(x)\\), welche nur zur Generierung der Datenpunkte verwendet wird.\n\\[ f(x) = \\frac{1}{2} + \\frac{1}{1+x^2}\\]\nZunächst werden die Messpunkte generiert.\n\ndef fnk(x):\n    return 0.5 + 1/(1+x**2)\n\n\nxmin = -5\nxmax =  5\nx = np.linspace(xmin, xmax, 100)\ny = fnk(x)\n\n\nn = 5\nxi = np.linspace(xmin, xmax, n)\nyi = fnk(xi)\n\nNun folgt die Interpolation für 5 und 15 Messpunkte.\n\nP = poly.polyfit(xi, yi, n-1)\nprint(\"Interpolationskoeffizienten:\")\nprint(P)\n\nInterpolationskoeffizienten:\n[ 1.50000000e+00 -1.12346671e-16 -1.71087533e-01  6.98020740e-18\n  5.30503979e-03]\n\n\n\nplt.plot(x, y, color='C0', alpha=0.5, label='generierende Funktion')\nplt.plot(x, poly.polyval(x, P), color='C2', label='Interpolation')\nplt.scatter(xi, yi, color='C1', label='Messpunkte', zorder=3)\nplt.legend()\nplt.grid()\n\nplt.show()\n\n\n\n\n\n\n\n\n\nn = 15\nxi = np.linspace(xmin, xmax, n)\nyi = fnk(xi)\n\nP = poly.polyfit(xi, yi, n-1)\n\nplt.plot(x, y, color='C0', alpha=0.5, label='generierende Funktion')\nplt.plot(x, poly.polyval(x, P), color='C2', label='Interpolation')\nplt.scatter(xi, yi, color='C1', label='Messpunkte', zorder=3)\nplt.legend()\nplt.grid()\n\nplt.show()\n\n\n\n\n\n\n\n\n \nDie Interpolation erfüllt immer die geforderte Bedingung \\(y(x_i) = y_i\\). Jedoch führen Polynome mit einem hohen Grad oft zu nicht sinnvollen Ergebnissen. Es entstehen starke Überschwinger, welche mit zunehmendem Grad immer stärker werden.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Interpolation – Lücken schließen</span>"
    ]
  },
  {
    "objectID": "skript/fitting.html",
    "href": "skript/fitting.html",
    "title": "3  Fitting",
    "section": "",
    "text": "Beim Fitting wird eine Modellfunktion gesucht, welche die Messdaten nicht unbedingt exakt abbildet. Wird ein Polynom verwendet, so hat es einen Grad, welcher deutlich kleiner ist, als die Anzahl der Messpunkte. Lineare Regression ist ein Beispiel für ein Fitting durch ein Polynom mit dem Grad Eins.\nZum Fitten durch ein Polynom kann die Funktion numpy.polynomial.polynomial.polyfit() verwendet werden, genauso wie bei der Polynominterpolation. Diesmal jedoch mit einem kleineren Polynomgrad.\nIm folgenden Beispiel werden zunächst Modelldaten generiert und dann mit entsprechenden Polynomen gefittet.\n\nxmin = 0\nxmax = 5\nx = np.linspace(xmin, xmax, 100)\n\nni = 25\n\n# x-Werte mit leichtem Rauschen\nxi = np.linspace(xmin, xmax, ni) + 0.2*(2 * np.random.random(ni) -1)\n\n# y(x) = 2x+0.5 mit leichtem Rauschen\nyi = 2*xi + 0.5 + 2*(2 * np.random.random(ni) -1)\n\nplt.scatter(xi, yi, color='C1')\nplt.grid()\n\nplt.show()\n\n\n\n\n\n\n\n\n\nP1 = poly.polyfit(xi, yi, 1)\n\nplt.scatter(xi, yi, color='C1', zorder=3, label='Messpunkte')\nplt.plot(x, poly.polyval(x, P1), color='C0', label=\"Modellfunktion\")\nplt.grid()\nplt.legend()\n\nplt.show()\n\n\n\n\n\n\n\n\nIn diesem Beispiel werden ein Polynom ersten Grades und ein Polynom zweiten Grades bestimmt.\n\n# x-Werte mit leichtem Rauschen\nxi = np.linspace(xmin, xmax, ni) + 0.2*(2 * np.random.random(ni) -1)\n\n# y(x) = 2x+0.5 mit leichtem Rauschen\nyi = (xi - 2)**2 -2*xi + 2.5 + 2*(2 * np.random.random(ni) -1)\n\n\nP1 = poly.polyfit(xi, yi, 1)\nP2 = poly.polyfit(xi, yi, 2)\n\nplt.scatter(xi, yi, color='C1', zorder=3, label='Messpunkte')\nplt.plot(x, poly.polyval(x, P1), color='C0', label=\"Modellfunktion, Grad 1\")\nplt.plot(x, poly.polyval(x, P2), color='C2', label=\"Modellfunktion, Grad 2\")\nplt.grid()\nplt.legend()\n\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Fitting</span>"
    ]
  },
  {
    "objectID": "skript/splines.html",
    "href": "skript/splines.html",
    "title": "4  Splines",
    "section": "",
    "text": "4.1 Definition\nPolynominterpolation versucht eine globale Modellfunktion zu finden. Jedoch eignen sich Polynome mit hohen Graden im Allgemeinen nicht für eine Interpolation vieler Punkte. Einen anderen Ansatz verfolgen Splines (auch: Polynomzug), welche mehrere, niedrige Polynome zur Interpolation vieler Punkte verwenden. Die Polynome haben typischerweise Grade zwischen eins und drei.\nFür \\(n+1\\) Messpunkte \\((x_i, y_i)\\) kann eine Splinefunktion \\(s_k\\), hier ein Polynomspline, wie folgt definiert werden:\nBeispiele:",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Splines</span>"
    ]
  },
  {
    "objectID": "skript/splines.html#definition",
    "href": "skript/splines.html#definition",
    "title": "4  Splines",
    "section": "",
    "text": "Vorausgesetzt ist, dass die Messpunkte sortiert sind, d. h. \\(x_0 &lt; x_1 &lt; \\cdots &lt; x_n\\).\nFür jedes \\(i = 0\\dots n − 1\\) ist \\(s_k\\) ein Polynom vom Grad \\(k\\) auf dem Intervall \\(\\left[x_i , x_{i+1}\\right]\\)\n\\(s_k\\) ist auf \\(\\left[x_0 , x_n \\right]\\) \\((k − 1)\\)-mal stetig differenzierbar\n\n\n\n\\(k = 1\\): Polygonzug\n\\(k = 3\\): kubische Polynomsplines (B-Splines)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Splines</span>"
    ]
  },
  {
    "objectID": "skript/splines.html#kubische-splines",
    "href": "skript/splines.html#kubische-splines",
    "title": "4  Splines",
    "section": "4.2 Kubische Splines",
    "text": "4.2 Kubische Splines\nDie in der Praxis häufig eingesetzten kubischen Polynomsplines \\(s_3\\) (\\(k = 3\\)) haben folgende Eigenschaften:\n\n\\(s_3|\\left[x_i,x_{i+1}\\right] = \\beta_0 +\\beta_1 x + \\beta_2 x^2 + \\beta_3 x^3\\)\n\\(s_3\\) ist zweimal stetig differenzierbar auf \\(\\left[x_0,x_n\\right]\\), also insbesondere an den Stützpunkten \\(x_i\\) der Messpunkte.\n\nDie Koeffizienten \\(\\beta_i\\) werden wie folgt bestimmt:\n\nAus den \\(n + 1\\) Messpunkten ergeben sich \\(n\\) Intervalle, d. h. mit jeweils vier Koeffizienten sind es insgesamt \\(4n\\) Koeffizienten.\nExakte Darstellung der Messpunkte (\\(n + 1\\) Gleichungen), d. h.: \\(s_3(x_i) = y_i\\)\nGlattheitsbedingungen an den inneren Messpunkten (\\(i=1 \\dots n-1\\)), mit jeweils (\\(n − 1\\) Gleichungen): \\[\ns_3'(x_i)_- =s_3'(x_i)_+\n\\] \\[\ns_3''(x_i)_- =s_3''(x_i)_+\n\\] \\[\ns_3'''(x_i)_- =s_3'''(x_i)_+\n\\]\nDamit sind es \\(4n − 2\\) Gleichungen für \\(4n\\) Koeffizienten.\n\nUm die beiden fehlenden Gleichungen zu finden bzw. zu bestimmen, werden Randbedingungen oder Abschlussbedingungen benötigt. Die gängigsten Bedingungen sind:\n\nnatürliche Splines: die Krümung am Rand verschwindet, d. h.: \\[\ns_3''(x_0) = s_3''(x_n) = 0\n\\]\nperiodische Splines: die Steigung und Krümung ist an beiden Rändern gleich \\[\ns_3'(x_0) = s_3'(x_n)\n\\]\n\n\\[\ns_3''(x_0) = s_3''(x_n)\n\\]\n\nHermite Splines: die Steigungen am Rand werden explizit vorgegeben (hier durch \\(u\\) und \\(v\\)) \\[\ns_3'(x_0) = u\n\\] \\[\ns_3'(x_n) = v\n\\]",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Splines</span>"
    ]
  },
  {
    "objectID": "skript/splines.html#anwendung",
    "href": "skript/splines.html#anwendung",
    "title": "4  Splines",
    "section": "4.3 Anwendung",
    "text": "4.3 Anwendung\nIm Folgenden werden zwei Beispiele, \\(s_1\\) und \\(s_3\\), für die Erstellung von Splines mit Python vorgestellt.\n\n# Erzeugung von Messpunkten\nn = 7\nxi = np.linspace(0, np.pi, n)\nyi = np.sin(xi)\n\nFür die \\(s_1\\) Splines, kann die Funktion np.interp() verwendet werden. Sie führt eine lineare Interpolation zwischen gegebenen Wertepaaren durch.\n\n# Wertebereich für die Visualisierung der Interpolation\nx = np.linspace(0, np.pi, n*6)\ny = np.sin(x)\n\n\n# Interpolation\ny_s1 = np.interp(x, xi, yi)\n\n\nplt.plot(x,y, alpha=0.3, color='C2', lw=5, \n         label='Generierende Funktion')\nplt.plot(x, y_s1, color='C0', label='Interpolation')\nplt.scatter(x, y_s1, s=3, zorder=3, color='C0')\nplt.scatter(xi, yi, color='C1', label='Messpunkte')\n\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend();\n\nplt.show()\n\n\n\n\n\n\n\n\n \nDie \\(s_3\\) Splines können mit Funktionen aus dem scipy-Modul berechnet werden. Dazu werden zunächst die Koeffizienten bestimmt (scipy.interpolate.splrep) und diese ermöglichen die gewünschte Auswertung, welche mit der Funktion scipy.interpolate.splev vorgenommen werden kann.\n\nimport scipy.interpolate as si\n\n\ns3 = si.splrep(xi, yi)\ny_s3 = si.splev(x, s3)\n\n\nplt.plot(x,y, alpha=0.3, color='C2', lw=5, \n         label='Generierende Funktion')\nplt.plot(x, y_s3, color='C0', label='Interpolation')\nplt.scatter(x, y_s3, s=3, zorder=3, color='C0')\nplt.scatter(xi, yi, color='C1', label='Messpunkte')\n\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend();\n\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Splines</span>"
    ]
  },
  {
    "objectID": "skript/glaetten.html",
    "href": "skript/glaetten.html",
    "title": "5  Trendglättung – Rauschen reduzieren",
    "section": "",
    "text": "Verrauschte Daten? Ein gleitender Mittelwert glättet Kurven:\n\ndata = np.genfromtxt(\"01-daten/trenddaten-mit-rauschen.csv\", delimiter=\",\", skip_header=1)\nx = data[:, 0]\ny = data[:, 1]\n\nwindow = 5\nweights = np.ones(window) / window\ny_smooth = np.convolve(y, weights, mode='valid')\n\nplt.plot(x, y, label=\"Original\", alpha=0.5)\nplt.plot(x[(window-1)//2:-(window//2)], y_smooth, label=\"Geglättet\", color='red')\nplt.legend()\nplt.grid(True)\nplt.title(\"Trendglättung\")\n\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Trendglättung – Rauschen reduzieren</span>"
    ]
  },
  {
    "objectID": "skript/uebungen.html",
    "href": "skript/uebungen.html",
    "title": "6  Übungen",
    "section": "",
    "text": "6.1 Übung: Ballonfahrt-Daten analysieren\nIn der Datei ‘01-daten/messdaten-ballonfahrt.txt’ sind Messdaten zur Höhe eines Ballons während einer Ballonfahrt gespeichert. In der ersten Zeile der Datei sind die gemessenen Größen und ihre Einheit notiert.\n# Dateikopf als String einlesen\nballon = np.genfromtxt(\"01-daten/messdaten-ballonfahrt.txt\", delimiter=\",\", max_rows= 4, dtype='str')\n\nprint(\"Der Kopf der Datei:\")\nprint(ballon)\n\nDer Kopf der Datei:\n[['Zeit (s)' 'Hoehe (m)']\n ['0.0' '49.93175839467537']\n ['2.0202020202020203' '52.11727320291297']\n ['4.040404040404041' '50.0624468191306']]\nSchauen wir uns die Daten einmal an:\nGesucht ist ein Polynom, das die Steiggeschwindigkeit, also die Änderung der Höhe mit der Zeit, des Heißluftballons beschreibt.\nSchreiben Sie ein Programm, das:\nStellen Sie die Höhe, die Geschwindigkeit und den Fit jeweils gegen die Zeit dar. Beschriften Sie die Achsen.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Übungen</span>"
    ]
  },
  {
    "objectID": "skript/uebungen.html#übung-ballonfahrt-daten-analysieren",
    "href": "skript/uebungen.html#übung-ballonfahrt-daten-analysieren",
    "title": "6  Übungen",
    "section": "",
    "text": "die Höhe aus den Daten ausliest und die Steiggeschwindigkeit berechnet,\neinen Fit der Steiggeschwindigkeit mit einem Polynom dritten Grades durchführt.\n\n\n\n\n\n\n\n\nTipp 6.1: Musterlösung Ballonfahrt\n\n\n\n\n\nZuerst werden die Daten ausgelesen.\n\n# Daten auslesen\nballon = np.genfromtxt(\"01-daten/messdaten-ballonfahrt.txt\", delimiter=\",\", skip_header=1)\nzeit = ballon[:, 0]\nhoehe = ballon[:, 1]\n\nAnschließend berechnen wir die Steiggeschwindigkeit \\(\\frac{\\Delta Höhe}{\\Delta Zeit}\\). Dazu verwenden wir die Funktion np.diff(). Diese berechnet die Differenz jedes Werts zu seinem Vorgänger ergebnis[i] = wert[i+1] - wert[i]. Für den i-ten Wert wird also keine Differenz berechnet und das Ergebnis ist um ein Element kürzer. Die Steiggeschwindigkeit in \\(\\frac{m}{s}\\) ergibt sich aus dem Quotienten beider Reihen.\n\n# Differenzen berechnen\ndelta_hoehe = np.diff(hoehe)\nprint(\"Veränderung der Höhe: \", delta_hoehe[0:4])\n\ndelta_zeit = np.diff(zeit)\nprint(\"Veränderung der Zeit: \", delta_zeit[0:4])\n\n# Steiggeschwindigkeit berechnen\nsteiggeschwindigkeit = delta_hoehe / delta_zeit\nprint(\"Steiggeschwindigkeit: \", steiggeschwindigkeit[0:4])\n\nVeränderung der Höhe:  [ 2.18551481 -2.05482638  0.32026988  1.12796595]\nVeränderung der Zeit:  [2.02020202 2.02020202 2.02020202 2.02020202]\nSteiggeschwindigkeit:  [ 1.08182983 -1.01713906  0.15853359  0.55834314]\n\n\nMit numpy.polynomial.polynomial.polyfit() berechnen wir erst ein Polynom dritten Grades und dann mit numpy.polynomial.polynomial.polyval() die gefitteten Daten.\n\npolynom3_steiggeschwindigkeit = poly.polyfit(zeit[:-1], steiggeschwindigkeit, deg = 3)\n\nfit_steiggeschwindigkeit = poly.polyval(x = zeit[:-1], c = polynom3_steiggeschwindigkeit)\n\n\n# plotten\nplt.suptitle(\"Ballonfahrt\")\n\n## subplot Höhe über Zeit\nplt.subplot(1, 3, 1)\nplt.scatter(zeit, hoehe)\nplt.title(\"Höhe\")\nplt.xlabel(\"Zeit (s)\")\nplt.ylabel(\"Höhe (m)\")\nplt.grid(True)\n\n## subplot Steiggeschwindigkeit über Zeit\n## Länge des Arrays Steiggeschwindigkeit ist n-1\nplt.subplot(1, 3, 2)\nplt.scatter(zeit[:-1], steiggeschwindigkeit)\nplt.title(\"Steiggeschwindigkeit\")\nplt.xlabel(\"Zeit (s)\")\nplt.ylabel(\"Steiggeschwindigkeit (m/s)\")\nplt.grid(True)\n\n## subplot Polynom 3. Grades Steiggeschwinkdigkeit über Zeit\n## Länge des Arrays Steiggeschwindigkeit ist n-1\nplt.subplot(1, 3, 3)\nplt.plot(zeit[:-1], fit_steiggeschwindigkeit)\nplt.title(\"interpolierte\\nSteiggeschwindigkeit\")\nplt.xlabel(\"Zeit (s)\")\nplt.ylabel(\"Steiggeschwindigkeit (m/s)\")\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Übungen</span>"
    ]
  },
  {
    "objectID": "skript/uebungen.html#übung-balkenverformung-im-bauingenieurwesen",
    "href": "skript/uebungen.html#übung-balkenverformung-im-bauingenieurwesen",
    "title": "6  Übungen",
    "section": "6.2 Übung: Balkenverformung im Bauingenieurwesen",
    "text": "6.2 Übung: Balkenverformung im Bauingenieurwesen\nEin Träger wird in der Mitte belastet.\n\n\n\n\nBeispiel für einen Versuchsaufbau Balkenverformung\n\n\nBalkenverformung von Universität der Bundeswehr München. Das Werk ist abrufbar auf der Internetseite der UniBw M. ohne Jahr\n\n \nSchauen wir uns die Struktur der Daten einmal an.\n\nbalken = np.genfromtxt(\"01-daten/balken-durchbiegung.csv\", delimiter=\",\", max_rows= 4, dtype='str')\n\nprint(\"Der Kopf der Datei:\")\nprint(balken)\n\nDer Kopf der Datei:\n[['Position (m)' 'Durchbiegung (mm)']\n ['0.0' '-0.28820719619532215']\n ['0.20408163265306123' '-0.22193122300286544']\n ['0.40816326530612246' '0.013978362500916705']]\n\n\nDie Durchbiegung wird an 50 Punkten gemessen. Glätten Sie die Daten und stellen Sie die gemessenen und die geglätteten Daten gemeinsam dar.\n\n\n\n\n\n\nTipp 6.2: Musterlösung Balken\n\n\n\n\n\n\nbalken = np.genfromtxt(\"01-daten/balken-durchbiegung.csv\", delimiter=\",\", skip_header=1)\nx = balken[:, 0]\ny = balken[:, 1]\n\nwindow = 7\nweights = np.ones(window) / window\ny_smooth = np.convolve(y, weights, mode='valid')\n\nplt.plot(x, y, label=\"Messung\", alpha=0.5)\nplt.plot(x[(window-1)//2:-(window//2)], y_smooth, label=\"Geglättet\", color='red')\nplt.title(\"Durchbiegung eines Trägers\")\nplt.xlabel(\"Position (m)\")\nplt.ylabel(\"Durchbiegung (mm)\")\nplt.legend()\nplt.grid(True)\n\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Übungen</span>"
    ]
  },
  {
    "objectID": "skript/uebungen.html#übung-neutronenstreuung",
    "href": "skript/uebungen.html#übung-neutronenstreuung",
    "title": "6  Übungen",
    "section": "6.3 Übung: Neutronenstreuung",
    "text": "6.3 Übung: Neutronenstreuung\nDie Datei ‘01-daten/neutronen.txt’ enthält Daten eines Neutronenstreuexperiments. Der Dateikopf:\n\n# Dateikopf als String einlesen\nneutronen = np.genfromtxt(\"01-daten/neutronen.txt\", delimiter=\"\\t\", max_rows= 4, dtype='str')\nprint(neutronen)\n\n[['E(MeV)' 'sigma(mb)' 'Delta sigma(mb)']\n ['0.00' '10.60' ' 1.39']\n ['25.00' '16.00' ' 2.09']\n ['50.00' '45.00' ' 3.85']]\n\n\nIn der Spalte ‘E(MeV)’ ist die Energie eines Neutrons, das auf ein Ziel geschossen wird, in Megaelektronenvolt eingetragen. In der Spalte ‘sigma(mb)’ ist der Wirkungsquerschnitt, gemessen in Millibarn (mb), eingetragen. In der Spalte ‘Delta sigma(mb)’ ist die Unsicherheit des gemessenen Wirkungsquerschnitts, ebenfalls in Millibarn (mb), eingetragen.\n\nLesen Sie die Daten ein\nVersuchen Sie die ersten zwei Spalten mit einem Polynom eines geeigneten Grades zu fitten und stellen Sie das Ergebnis graphisch dar.\nFitten Sie die Daten erneut, aber nutzen Sie dieses Mal Splines.\nStellen Sie das Ergebnis ebenfalls graphisch dar und vergleichen Sie mit den Polynomfit.\nWas sind die Vor- und Nachteile der jeweiligen Varianten?\n\n\n\n\n\n\n\nTipp 6.3: Musterlösung Neutronenstreuung\n\n\n\n\n\n\nDaten einlesen\n\n\nneutronen = np.genfromtxt(\"01-daten/neutronen.txt\", delimiter=\"\\t\", skip_header=1)\nneutronenenergie = neutronen[:, 0]\nwirkungsquerschnitt = neutronen[:, 1]\n\nplt.plot(neutronenenergie, wirkungsquerschnitt, label=\"Messdaten\", alpha=0.5)\nplt.xlabel(\"Neutronenenergie (MeV)\")\nplt.ylabel(\"Wirkungsquerschnitt (mb)\")\nplt.legend()\nplt.grid(True)\n\nplt.show()\n\n\n\n\n\n\n\n\n \n\n\n\nPolynom und Splines fitten:\n\n\n\n\n# Polynom \npolynom5 = poly.polyfit(neutronenenergie, wirkungsquerschnitt, deg = 5)\nfit =  poly.polyval(x = neutronenenergie, c = polynom5)\n\n# Splines mit scipy\nsplines3 = si.splrep(neutronenenergie, wirkungsquerschnitt)\ny_splines3 = si.splev(neutronenenergie, splines3)\n\n# Splines mit NumPy\nx_neu = np.linspace(neutronenenergie.min(), neutronenenergie.max(), num=50)\ny_splines1 = np.interp(x_neu, neutronenenergie, wirkungsquerschnitt) # linear interpolieren\n\n\nGrafische Darstellung:\n\n\nplt.figure(figsize = [7, 5])\n\n# Vergleich mit kubischen Splines\nplt.subplot(2, 1, 1)\nplt.plot(neutronenenergie, wirkungsquerschnitt, linewidth = 5, alpha=0.3, label=\"Messdaten\")\nplt.plot(neutronenenergie, fit, label = \"gefittetes Polynom\")\nplt.plot(neutronenenergie, y_splines3, linestyle = 'dashdot', label = \"kubische Splines\")\nplt.xlabel(\"Neutronenenergie (MeV)\")\nplt.ylabel(\"Wirkungsquerschnitt (mb)\")\nplt.legend()\nplt.grid(True)\n\n# Vergleich mit linearen Splines\nplt.subplot(2, 1, 2)\nplt.plot(neutronenenergie, wirkungsquerschnitt, linewidth = 5, alpha=0.3, label=\"Messdaten\")\nplt.plot(neutronenenergie, fit, label = \"gefittetes Polynom\")\n\nplt.plot(x_neu, y_splines1, linestyle = 'dotted', label = 'lineare Splines')\nplt.xlabel(\"Neutronenenergie (MeV)\")\nplt.ylabel(\"Wirkungsquerschnitt (mb)\")\nplt.legend()\nplt.grid(True)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n \n5.: Die Splines bilden die Daten exakt nach. Das kann ein Vorteil sein, wenn keine Glättung der Daten gewünscht ist. Das Polynom ist dagegen nicht exakt an die Daten angepasst. Dafür können alle Datenpunkte mit einer einzigen Modellgleichung approximiert werden.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Übungen</span>"
    ]
  }
]